<!DOCTYPE html>
<html lang="bn">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Messaging App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <!-- Load Socket.IO client from backend server explicitly -->
    <script src="http://localhost:5002/socket.io/socket.io.js"></script>
    <style>
      :root {
        --bg: #0b0f14;
        --panel: #121821;
        --muted: #99a3ad;
        --text: #e6edf3;
        --primary: #3b82f6;
        --success: #22c55e;
        --danger: #ef4444;
        --border: #1f2937;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }
      .app {
        display: grid;
        grid-template-rows: auto 1fr;
        height: 100vh;
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 16px;
        border-bottom: 1px solid var(--border);
        background: var(--panel);
      }
      header .brand { font-weight: 600; }
      header .user {
        display: flex; gap: 8px; align-items: center;
        color: var(--muted);
      }
      .layout {
        display: grid;
        grid-template-columns: 320px 1fr;
        height: calc(100vh - 52px);
      }
      .sidebar {
        border-right: 1px solid var(--border);
        background: var(--panel);
        display: grid;
        grid-template-rows: auto auto 1fr;
      }
      .login {
        padding: 12px;
        border-bottom: 1px solid var(--border);
        display: grid;
        gap: 8px;
      }
      .login input {
        width: 100%;
        padding: 10px 12px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #0d1218;
        color: var(--text);
      }
      .login button {
        padding: 10px 12px;
        border-radius: 8px;
        border: 0;
        background: var(--primary);
        color: white;
        cursor: pointer;
      }
      .status {
        padding: 10px 12px;
        border-bottom: 1px solid var(--border);
        display: flex; gap: 8px; align-items: center;
        font-size: 13px; color: var(--muted);
      }
      .chat-list {
        overflow-y: auto;
      }
      .chat-item {
        padding: 10px 12px;
        border-bottom: 1px solid var(--border);
        display: grid; grid-template-columns: 40px 1fr auto; gap: 10px; align-items: center;
        cursor: pointer;
      }
      .chat-item:hover { background: #0d1218; }
      .avatar { width: 40px; height: 40px; border-radius: 50%; background: #1f2937; }
      .name { font-weight: 600; }
      .preview { font-size: 12px; color: var(--muted); }
      .badge {
        min-width: 22px; height: 22px; padding: 0 7px;
        border-radius: 11px; background: var(--primary); color: white; display: inline-flex; align-items: center; justify-content: center; font-size: 12px;
      }
      .presence { width: 10px; height: 10px; border-radius: 50%; }
      .presence.online { background: var(--success); }
      .presence.offline { background: var(--danger); opacity: 0.7; }

      .main {
        display: grid;
        grid-template-rows: auto 1fr auto;
      }
      .thread-header {
        padding: 10px 16px;
        border-bottom: 1px solid var(--border);
        background: var(--panel);
        display: flex; align-items: center; gap: 12px;
      }
      .messages {
        padding: 16px;
        overflow-y: auto;
        display: flex; flex-direction: column; gap: 8px;
        background: #0a0e13;
      }
      .msg {
        max-width: 70%;
        padding: 10px 12px;
        border-radius: 12px;
        background: #111827;
      }
      .msg.me { align-self: flex-end; background: #1f2937; }
      .msg .meta { font-size: 11px; color: var(--muted); margin-top: 4px; }
      /* Message status labels */
      .msg .status { margin-left: 6px; }
      .msg .status.sent { color: var(--muted); }
      .msg .status.delivered { color: var(--muted); }
      .msg .status.seen { color: #60a5fa; }
      .composer {
        padding: 10px 16px; border-top: 1px solid var(--border); background: var(--panel);
        display: grid; grid-template-columns: auto 1fr auto; gap: 10px;
      }
      .composer input {
        width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid var(--border); background: #0d1218; color: var(--text);
      }
      .composer button { padding: 10px 16px; border-radius: 8px; border: 0; background: var(--primary); color: white; cursor: pointer; }
      .typing { font-size: 12px; color: var(--muted); padding: 4px 16px; }
      .hidden { display: none; }
      .attach-btn { background: #374151; }
      .attachment-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; margin-top: 6px; }
      .attachment-card { background: #0d1218; border: 1px solid var(--border); border-radius: 8px; padding: 6px; font-size: 12px; color: var(--muted); position: relative; }
      .attachment-thumb { width: 100%; height: 100px; object-fit: cover; border-radius: 6px; background: #111827; }
      .uploading { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.35); color: #fff; font-size: 12px; border-radius: 8px; }
    </style>
  </head>
  <body>
    <div class="app">
      <header>
        <div class="brand">üí¨ Messaging</div>
        <div class="user"><span id="userEmail">Not logged in</span><span id="userRole" style="margin-left:8px"></span><button id="logoutBtn" class="hidden" style="margin-left:8px;background:#374151;color:#fff;border:0;border-radius:6px;padding:6px 10px;cursor:pointer">Logout</button></div>
      </header>
      <div class="layout">
        <aside class="sidebar">
          <div class="login" id="loginSection">
            <input id="email" type="email" placeholder="‡¶á‡¶Æ‡ßá‡¶á‡¶≤" />
            <input id="password" type="password" placeholder="‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶°" />
            <button id="loginBtn">Login</button>
            <div id="loginMsg" style="font-size:12px;color:var(--muted)"></div>
          </div>
          <div class="status">
            <span>Server: <strong id="serverUrl">http://localhost:5000</strong></span>
            <span id="connectionDot" class="presence offline" title="Socket"></span>
          </div>
          <div class="chat-list" id="chatList"></div>
        </aside>
        <main class="main">
          <div class="thread-header" id="threadHeader">
            <div class="avatar" id="threadAvatar"></div>
            <div>
              <div class="name" id="threadName">Select a chat</div>
              <div class="preview" id="threadPresence">‚Äî</div>
            </div>
          </div>
          <div class="messages" id="messages"></div>
          <div class="typing hidden" id="typing">Typing...</div>
          <div class="composer">
            <button id="attachBtn" class="attach-btn">Attach</button>
            <input id="messageInput" type="text" placeholder="Type a message‚Ä¶" />
            <button id="sendBtn">Send</button>
            <input id="attachmentInput" class="hidden" type="file" multiple accept="image/*,video/*,audio/*,application/pdf" />
          </div>
        </main>
      </div>
    </div>

    <script>
      const DEFAULT_SERVER_ORIGIN = 'http://localhost:5002';
      // Always use backend origin, not the static page origin
      const SERVER_ORIGIN = DEFAULT_SERVER_ORIGIN;
      const API_BASE = SERVER_ORIGIN + '/api/v1';

      // State
      let token = localStorage.getItem('token') || '';
      let currentUser = null; // { id, role, email }
      let socket = null;
      let currentChatId = null;
      let typingTimer = null;
      const TYPING_DEBOUNCE = 1200;
      // Track rooms joined so we receive MESSAGE_SENT for all chats (inbox updates)
      const joinedChatIds = new Set();
      // Track rendered message ids to avoid duplicate renders when optimistic append + socket event both fire
      const renderedMessageIds = new Set();
      // No global fallback channel to avoid duplicate messages

      const els = {
        email: document.getElementById('email'),
        password: document.getElementById('password'),
        loginBtn: document.getElementById('loginBtn'),
        loginMsg: document.getElementById('loginMsg'),
        loginSection: document.getElementById('loginSection'),
        serverUrl: document.getElementById('serverUrl'),
        connectionDot: document.getElementById('connectionDot'),
        userEmail: document.getElementById('userEmail'),
        userRole: document.getElementById('userRole'),
        logoutBtn: document.getElementById('logoutBtn'),
        chatList: document.getElementById('chatList'),
        threadName: document.getElementById('threadName'),
        threadPresence: document.getElementById('threadPresence'),
        messages: document.getElementById('messages'),
        typing: document.getElementById('typing'),
        messageInput: document.getElementById('messageInput'),
        sendBtn: document.getElementById('sendBtn'),
        attachBtn: document.getElementById('attachBtn'),
        attachmentInput: document.getElementById('attachmentInput'),
      };

      function decodeJWT(jwt) {
        try {
          const base64Url = jwt.split('.')[1];
          const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
          const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
          return JSON.parse(jsonPayload);
        } catch (e) { return null; }
      }

      async function api(path, method = 'get', body) {
        const headers = { 'Content-Type': 'application/json' };
        if (token) headers['Authorization'] = 'Bearer ' + token;
        const res = await fetch(API_BASE + path, {
          method: method.toUpperCase(),
          headers,
          body: body ? JSON.stringify(body) : undefined,
        });
        const json = await res.json().catch(() => ({}));
        if (!res.ok) {
          const err = new Error(json.message || ('HTTP ' + res.status));
          // attach status for easier handling
          // @ts-ignore
          err.status = res.status;
          throw err;
        }
        return json;
      }

      function setConnectionStatus(connected) {
        els.connectionDot.classList.toggle('online', connected);
        els.connectionDot.classList.toggle('offline', !connected);
      }

      function renderChatList(items) {
        els.chatList.innerHTML = '';
        if (!items || !items.length) {
          const empty = document.createElement('div');
          empty.style.color = 'var(--muted)';
          empty.style.padding = '12px';
          empty.textContent = '‡¶ï‡ßã‡¶®‡ßã ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø';
          els.chatList.appendChild(empty);
          return;
        }

        items.forEach(chat => {
          const other = chat.participants?.[0] || {};
          const li = document.createElement('div');
          li.className = 'chat-item';
          li.dataset.chatId = chat._id;
          li.innerHTML = `
            <div class="avatar" style="background-image:url('${other.image || ''}'); background-size:cover"></div>
            <div>
              <div class="name">${other.name || 'Unknown'}</div>
              <div class="preview">${chat.lastMessage?.text || ''}</div>
            </div>
            <div style="display:flex; align-items:center; gap:8px;">
              <span class="badge" style="${chat.unreadCount ? '' : 'display:none'}">${chat.unreadCount || ''}</span>
              <span class="presence ${chat.presence?.isOnline ? 'online' : 'offline'}" title="${chat.presence?.isOnline ? 'Online' : 'Offline'}"></span>
            </div>
          `;
          li.addEventListener('click', () => selectChat(chat._id, other));
          els.chatList.appendChild(li);
        });
      }

      function findChatItem(chatId) {
        return els.chatList.querySelector(`[data-chat-id="${chatId}"]`);
      }

      function joinChatRoom(chatId) {
        if (!socket || !chatId) return;
        const key = String(chatId);
        if (joinedChatIds.has(key)) return;
        joinedChatIds.add(key);
        try { socket.emit('JOIN_CHAT', { chatId }); } catch (e) {}
      }

      function joinAllChatRooms(chats) {
        if (!Array.isArray(chats)) return;
        chats.forEach(c => joinChatRoom(c?._id));
      }

      function updateChatListItem(chatId, { text, unreadIncrement = 0, resetUnread = false } = {}) {
        const li = findChatItem(chatId);
        if (!li) { /* fallback: reload list */ try { loadChats(); } catch (e) {} return; }
        const previewEl = li.querySelector('.preview');
        if (previewEl && typeof text === 'string') previewEl.textContent = text;
        const badgeEl = li.querySelector('.badge');
        if (badgeEl) {
          let count = parseInt(badgeEl.textContent || '0', 10);
          if (Number.isNaN(count)) count = 0;
          if (resetUnread) count = 0; else count = count + (unreadIncrement || 0);
          if (count > 0) {
            badgeEl.textContent = String(count);
            badgeEl.style.display = 'inline-flex';
          } else {
            badgeEl.textContent = '';
            badgeEl.style.display = 'none';
          }
        }
      }

      function renderAttachmentHtml(attList) {
        if (!Array.isArray(attList) || attList.length === 0) return '';
        const origin = SERVER_ORIGIN;
        const items = attList.map(att => {
          const url = String(att.url || '');
          const full = url.startsWith('http') ? url : origin + url;
          if (att.type === 'image') {
            return `<div class="attachment-card"><img class="attachment-thumb" src="${full}" alt="${att.name || ''}"/></div>`;
          }
          if (att.type === 'video') {
            return `<div class="attachment-card"><video class="attachment-thumb" src="${full}" controls></video></div>`;
          }
          if (att.type === 'audio') {
            return `<div class="attachment-card"><audio src="${full}" controls style="width:100%"></audio><div>${att.name || 'audio'}</div></div>`;
          }
          return `<div class="attachment-card"><a href="${full}" target="_blank" rel="noopener">${att.name || 'file'}</a></div>`;
        }).join('');
        return `<div class="attachment-grid">${items}</div>`;
      }

      function renderMessages(list, myId) {
        els.messages.innerHTML = '';
        list.forEach(m => {
          const el = document.createElement('div');
          const isMine = String(m.sender) === String(myId);
          el.className = 'msg' + (isMine ? ' me' : '');
          el.dataset.id = String(m._id || '');
          let statusHtml = '';
          if (isMine) {
            const readCount = Array.isArray(m.readBy) ? m.readBy.length : 0;
            const deliveredCount = Array.isArray(m.deliveredTo) ? m.deliveredTo.length : 0;
            const status = readCount > 0 ? 'seen' : (deliveredCount > 0 ? 'delivered' : 'sent');
            statusHtml = ` ¬∑ <span class="status status-${status}">${status}</span>`;
          }
          const attHtml = renderAttachmentHtml(m.attachments || []);
          el.innerHTML = `
            <div>${m.text || ''}</div>
            ${attHtml}
            <div class="meta">${new Date(m.createdAt).toLocaleString()} ¬∑ ${m.type}${statusHtml}</div>
          `;
          els.messages.appendChild(el);
        });
        els.messages.scrollTop = els.messages.scrollHeight;
      }

      async function selectChat(chatId, other) {
        currentChatId = chatId;
        els.threadName.textContent = other?.name || 'Chat';
        els.threadPresence.textContent = other?.presence?.isOnline ? 'Online' : 'Offline';
        joinChatRoom(chatId);
        // Removed global getMessage::<chatId> listener to prevent double inserts
        try {
          const res = await api(`/messages/${chatId}`, 'get');
          const { messages = [], participant = null } = res.data || {};
          renderMessages(messages, currentUser?.id);
          // Mark chat as read
          await api(`/messages/chat/${chatId}/read`, 'post');
          updateChatListItem(chatId, { resetUnread: true });
        } catch (err) {
          console.error(err);
        }
      }

      async function loadChats() {
        try {
          const res = await api('/chats/', 'get');
          renderChatList(res.data || []);
          // Join all chat rooms so we receive MESSAGE_SENT for inbox updates
          joinAllChatRooms(res.data || []);
        } catch (err) {
          // @ts-ignore
          const status = err?.status;
          if (status === 403) {
            els.loginMsg.textContent = '‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶≤‡ßã‡¶° ‡¶π‡¶Ø‡¶º‡¶®‡¶ø: ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∞‡ßã‡¶≤ ‡¶è‡¶á API ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡ßá‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á (POSTER/TASKER ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞)';
          } else if (status === 401) {
            els.loginMsg.textContent = '‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶≤‡ßã‡¶° ‡¶π‡¶Ø‡¶º‡¶®‡¶ø: ‡¶Ö‡¶•‡¶∞‡¶æ‡¶á‡¶ú‡ßá‡¶∂‡¶® ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶® ‡¶¨‡¶æ ‡¶∏‡¶†‡¶ø‡¶ï ‡¶®‡¶Ø‡¶º';
          } else {
            els.loginMsg.textContent = '‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶≤‡ßã‡¶° ‡¶π‡¶Ø‡¶º‡¶®‡¶ø: ' + err.message;
          }
        }
      }

      async function sendMessage() {
        const text = els.messageInput.value.trim();
        if (!text || !currentChatId) return;
        els.messageInput.value = '';
        try {
          const res = await api('/messages', 'post', { chatId: currentChatId, text });
          const msg = res.data;
          // Optimistic append; server also emits MESSAGE_SENT
          const mine = Array.isArray(msg) ? msg[0] : msg;
          const sentId = String(mine?._id || '');
          // If the socket event already rendered this message (arrived faster than POST response),
          // skip optimistic append to avoid duplicate for sender.
          if (!sentId || !renderedMessageIds.has(sentId)) {
            const el = document.createElement('div');
            el.className = 'msg me';
            el.dataset.id = sentId;
            const created = mine?.createdAt ? new Date(mine.createdAt).toLocaleString() : 'just now';
            el.innerHTML = `<div>${mine?.text || text}</div><div class="meta">${created} ¬∑ text ¬∑ <span class="status status-sent">sent</span></div>`;
            els.messages.appendChild(el);
            els.messages.scrollTop = els.messages.scrollHeight;
            // Track rendered id so the upcoming MESSAGE_SENT event doesn't duplicate
            if (sentId) renderedMessageIds.add(sentId);
          }
          // Update preview in chat list
          updateChatListItem(currentChatId, { text: mine?.text || text });
          // Ensure room membership is intact
          joinChatRoom(currentChatId);
          // Fallback: if socket event doesn't arrive quickly, refresh current thread
          setTimeout(async () => {
            try {
              const idOk = sentId && renderedMessageIds.has(sentId);
              if (!idOk) {
                const r = await api(`/messages/${currentChatId}`, 'get');
                const { messages = [] } = r.data || {};
                renderMessages(messages, currentUser?.id);
              }
            } catch {}
          }, 1200);
        } catch (err) {
          console.error('send failed', err);
        }
      }

      function classifyFieldName(file) {
        const t = file.type || '';
        if (t.startsWith('image/')) return 'image';
        if (t.startsWith('video/') || t.startsWith('audio/')) return 'media';
        return 'doc';
      }

      function createUploadPlaceholder(files, text) {
        const el = document.createElement('div');
        el.className = 'msg me';
        el.dataset.id = `upload-${Date.now()}-${Math.random().toString(36).slice(2,6)}`;
        const items = Array.from(files).map(f => {
          const field = classifyFieldName(f);
          if (field === 'image') {
            const url = URL.createObjectURL(f);
            return `<div class="attachment-card"><img class="attachment-thumb" src="${url}"/><div class="uploading">Uploading‚Ä¶</div></div>`;
          }
          if (field === 'media' && f.type.startsWith('video/')) {
            const url = URL.createObjectURL(f);
            return `<div class="attachment-card"><video class="attachment-thumb" src="${url}" muted></video><div class="uploading">Uploading‚Ä¶</div></div>`;
          }
          if (field === 'media') {
            return `<div class="attachment-card"><div>Audio: ${f.name}</div><div class="uploading">Uploading‚Ä¶</div></div>`;
          }
          return `<div class="attachment-card"><div>File: ${f.name}</div><div class="uploading">Uploading‚Ä¶</div></div>`;
        }).join('');
        const grid = `<div class="attachment-grid">${items}</div>`;
        const created = new Date().toLocaleString();
        el.innerHTML = `<div>${text || ''}</div>${grid}<div class="meta">${created} ¬∑ uploading</div>`;
        els.messages.appendChild(el);
        els.messages.scrollTop = els.messages.scrollHeight;
        return el;
      }

      async function uploadAttachments(files, text, placeholderEl) {
        if (!currentChatId || !token) return;
        const form = new FormData();
        form.append('chatId', currentChatId);
        if (text) form.append('text', text);
        Array.from(files).forEach(file => {
          const field = classifyFieldName(file);
          form.append(field, file);
        });
        try {
          const res = await fetch(API_BASE + '/messages', {
            method: 'POST',
            headers: { Authorization: 'Bearer ' + token },
            body: form,
          });
          const json = await res.json();
          if (!res.ok) throw new Error(json?.message || ('HTTP ' + res.status));
          const msg = json?.data;
          const id = String(msg?._id || '');
          if (id) renderedMessageIds.add(id);
          const created = msg?.createdAt ? new Date(msg.createdAt).toLocaleString() : 'just now';
          const attHtml = renderAttachmentHtml(msg?.attachments || []);
          placeholderEl.dataset.id = id || placeholderEl.dataset.id;
          placeholderEl.innerHTML = `<div>${msg?.text || text || ''}</div>${attHtml}<div class="meta">${created} ¬∑ ${msg?.type || 'mixed'} ¬∑ <span class="status status-sent">sent</span></div>`;
          joinChatRoom(currentChatId);
          updateChatListItem(currentChatId, { text: msg?.text || text || '[attachments]' });
        } catch (err) {
          try {
            const meta = placeholderEl.querySelector('.meta');
            if (meta) meta.textContent = 'Upload failed';
          } catch {}
          console.error('upload failed', err);
        }
      }

      function handleAttachmentSelection(ev) {
        const files = ev.target.files;
        if (!files || files.length === 0 || !currentChatId) return;
        const text = els.messageInput.value.trim();
        els.messageInput.value = '';
        const ph = createUploadPlaceholder(files, text);
        uploadAttachments(files, text, ph);
        try { ev.target.value = ''; } catch {}
      }

      function setupSocket() {
        if (!token) return;
        // Clean up old socket to avoid duplicate listeners
        if (socket) {
          try { socket.off(); socket.disconnect(); } catch (e) {}
          socket = null;
        }
        setConnectionStatus(false);
        // Track consecutive connect errors to aid debugging/recovery
        let connectErrorStreak = 0;
        let connectErrorResetTimer = null;
        try {
          socket = io(SERVER_ORIGIN, {
            auth: { token },
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 800,
            timeout: 20000,
          });
        } catch (e) { console.error(e); return; }
        socket.on('connect', () => {
          setConnectionStatus(true);
          // Reset error streak on successful connection
          connectErrorStreak = 0;
          if (connectErrorResetTimer) { try { clearTimeout(connectErrorResetTimer); } catch {} connectErrorResetTimer = null; }
          // Re-join previously joined chat rooms on reconnect
          try { joinedChatIds.forEach(id => socket.emit('JOIN_CHAT', { chatId: id })); } catch (e) {}
        });
        socket.on('disconnect', () => {
          setConnectionStatus(false);
        });
        // Update auth before reconnect attempts
        try {
          socket.io.on?.('reconnect_attempt', () => {
            try { if (socket && socket.io && socket.io.opts) socket.io.opts.auth = { token }; } catch (e) {}
          });
        } catch {}
        socket.on('connect_error', (err) => {
          setConnectionStatus(false);
          // Increment error streak and schedule a reset window
          connectErrorStreak++;
          if (connectErrorResetTimer) { try { clearTimeout(connectErrorResetTimer); } catch {} }
          connectErrorResetTimer = setTimeout(() => { connectErrorStreak = 0; }, 6000);

          // Show detailed status for debugging
          const msg = '‡¶∏‡¶ï‡ßá‡¶ü ‡¶ï‡¶æ‡¶®‡ßá‡¶ï‡¶∂‡¶® ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: ' + (err?.message || 'Unknown error');
          try { els.loginMsg.textContent = msg; } catch {}
          console.warn('[socket connect_error]', { message: err?.message, data: err?.data, streak: connectErrorStreak, server: SERVER_ORIGIN });

          // If repeated failures occur with a token, hint that token might be invalid/expired
          if (connectErrorStreak >= 2 && token) {
            try {
              els.loginMsg.textContent = msg + ' ‚Äî ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡ßÅ‡¶® (‡¶∏‡¶Æ‡ßç‡¶≠‡¶¨‡¶§ ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶°)‡•§';
              // Keep UI in a recoverable state: show login panel without force-clearing token
              els.logoutBtn.classList.remove('hidden');
              els.loginSection.classList.remove('hidden');
            } catch {}
          }

          // After multiple consecutive failures, clear token to force fresh auth
          if (connectErrorStreak >= 3 && token) {
            try {
              localStorage.removeItem('token');
              token = '';
              currentUser = null;
              console.warn('[socket] clearing token after repeated failures');
              els.userEmail.textContent = 'Not logged in';
              els.userRole.textContent = '';
              els.logoutBtn.classList.add('hidden');
              els.loginSection.classList.remove('hidden');
              try { socket?.off(); socket?.disconnect(); } catch {}
            } catch {}
          }
        });
        socket.on('error', (err) => { console.error('socket error', err); });

        // Real-time events
        socket.on('MESSAGE_SENT', (payload) => {
          const id = String(payload?.messageId || payload?.message?._id || '');
          const isMine = String(payload.sender) === String(currentUser?.id);
          const isCurrent = String(payload.chatId) === String(currentChatId);

          // Avoid duplicate render for my own sent message when optimistic append already done
          if (isMine && id && renderedMessageIds.has(id)) {
            return;
          }
          if (id) renderedMessageIds.add(id);

          // Always update chat list preview
          updateChatListItem(payload.chatId, {
            text: payload.text || '',
            unreadIncrement: (!isMine && !isCurrent) ? 1 : 0,
            resetUnread: (!isMine && isCurrent) ? true : false,
          });

          // Always send delivered ack when I am the receiver, regardless of current thread
          if (!isMine && id) {
            try { socket.emit('DELIVERED_ACK', { messageId: id, chatId: payload.chatId }); } catch {}
          }

          // If current thread is open, append to messages
          if (isCurrent) {
            const el = document.createElement('div');
            el.className = 'msg' + (isMine ? ' me' : '');
            el.dataset.id = id;
            const statusHtml = isMine ? ` ¬∑ <span class="status status-sent">sent</span>` : '';
            el.innerHTML = `<div>${payload.text || ''}</div><div class="meta">${new Date(payload.createdAt).toLocaleString()} ¬∑ ${payload.type}${statusHtml}</div>`;
            els.messages.appendChild(el);
            els.messages.scrollTop = els.messages.scrollHeight;

            // If it's from other user and current chat is open, mark as read
            if (!isMine) {
              api(`/messages/chat/${payload.chatId}/read`, 'post').catch(() => {});
            }
          }
        });

        // Update status to delivered when receiver acknowledges
        socket.on('MESSAGE_DELIVERED', ({ messageId, chatId, userId }) => {
          // Only update if bubble exists and belongs to me
          if (String(chatId) !== String(currentChatId)) return;
          const statusEl = els.messages.querySelector(`.msg[data-id="${String(messageId)}"] .status`);
          const bubble = els.messages.querySelector(`.msg[data-id="${String(messageId)}"]`);
          if (statusEl && bubble && bubble.classList.contains('me')) {
            statusEl.textContent = 'delivered';
            statusEl.classList.remove('status-sent', 'status-seen');
            statusEl.classList.add('status-delivered');
          }
        });

        socket.on('TYPING_START', ({ userId, chatId }) => {
          if (String(chatId) !== String(currentChatId) || String(userId) === String(currentUser?.id)) return;
          els.typing.classList.remove('hidden');
        });
        socket.on('TYPING_STOP', ({ userId, chatId }) => {
          if (String(chatId) !== String(currentChatId) || String(userId) === String(currentUser?.id)) return;
          els.typing.classList.add('hidden');
        });

        socket.on('MESSAGE_READ', ({ messageId, chatId, userId }) => {
          // Update status to seen for my messages
          if (String(chatId) !== String(currentChatId)) return;
          const statusEl = els.messages.querySelector(`.msg[data-id="${String(messageId)}"] .status`);
          const bubble = els.messages.querySelector(`.msg[data-id="${String(messageId)}"]`);
          if (statusEl && bubble && bubble.classList.contains('me')) {
            statusEl.textContent = 'seen';
            statusEl.classList.remove('status-sent', 'status-delivered');
            statusEl.classList.add('status-seen');
          }
        });

        socket.on('USER_ONLINE', ({ userId, chatId }) => {
          if (String(chatId) === String(currentChatId)) {
            els.threadPresence.textContent = 'Online';
          }
        });
        socket.on('USER_OFFLINE', ({ userId, chatId }) => {
          if (String(chatId) === String(currentChatId)) {
            els.threadPresence.textContent = 'Offline';
          }
        });
      }

      async function handleLogin() {
        const email = els.email.value.trim();
        const password = els.password.value.trim();
        els.loginMsg.textContent = '';
        try {
          const res = await fetch(API_BASE + '/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password }),
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) throw new Error(data.message || ('HTTP ' + res.status));
          token = data?.data || '';
          localStorage.setItem('token', token);
          currentUser = decodeJWT(token) || null;
          els.userEmail.textContent = currentUser?.email || email;
          els.userRole.textContent = currentUser?.role ? `(role: ${currentUser.role})` : '';
          els.logoutBtn.classList.remove('hidden');
          els.loginSection.classList.add('hidden');
          setupSocket();
          await loadChats();
        } catch (err) {
          els.loginMsg.textContent = '‡¶≤‡¶ó‡¶á‡¶® ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•: ' + (err?.message || '‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï/‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶è‡¶∞‡¶∞');
        }
      }

      function handleLogout() {
        token = '';
        localStorage.removeItem('token');
        currentUser = null;
        currentChatId = null;
        try { socket?.off(); socket?.disconnect(); } catch (e) {}
        setConnectionStatus(false);
        joinedChatIds.clear();
        els.userEmail.textContent = 'Not logged in';
        els.logoutBtn.classList.add('hidden');
        els.loginSection.classList.remove('hidden');
        els.chatList.innerHTML = '';
        els.messages.innerHTML = '';
        els.threadName.textContent = 'Select a chat';
        els.threadPresence.textContent = '‚Äî';
      }

      function handleTyping() {
        if (!socket || !currentChatId) return;
        socket.emit('TYPING_START', { chatId: currentChatId });
        clearTimeout(typingTimer);
        typingTimer = setTimeout(() => {
          socket.emit('TYPING_STOP', { chatId: currentChatId });
        }, TYPING_DEBOUNCE);
      }

      // Wire up UI
      els.loginBtn.addEventListener('click', handleLogin);
      els.logoutBtn.addEventListener('click', handleLogout);
      els.sendBtn.addEventListener('click', sendMessage);
      els.messageInput.addEventListener('input', handleTyping);
      els.attachBtn.addEventListener('click', () => els.attachmentInput.click());
      els.attachmentInput.addEventListener('change', handleAttachmentSelection);

      // Auto-login if token exists
      (function init() {
        els.serverUrl.textContent = SERVER_ORIGIN;
        if (token) {
          currentUser = decodeJWT(token);
          if (currentUser) {
            els.userEmail.textContent = currentUser.email || 'Logged in';
            els.userRole.textContent = currentUser?.role ? `(role: ${currentUser.role})` : '';
            els.logoutBtn.classList.remove('hidden');
            els.loginSection.classList.add('hidden');
            setupSocket();
            loadChats();
          } else {
            localStorage.removeItem('token');
          }
        }
      })();
      // Enhance: rehydrate attachments in MESSAGE_SENT if another handler already rendered text-only
      // This avoids duplicate bubbles and upgrades existing one with attachment grid.
      if (socket && typeof socket.on === 'function') {
        socket.on('MESSAGE_SENT', payload => {
          try {
            if (!payload || String(payload.chatId) !== String(currentChatId)) return;
            const id = String(payload._id || '');
            if (!id) return;
            const children = Array.from(els.messages.children || []);
            const existing = children.find(x => String(x.dataset?.id) === id);
            if (!existing) return; // another handler hasn't rendered; let it do so
            const isMine = String(payload.sender) === String(currentUser?.id);
            existing.className = 'msg' + (isMine ? ' me' : '');
            const attHtml = renderAttachmentHtml(payload.attachments || []);
            existing.innerHTML = `<div>${payload.text || ''}</div>${attHtml}<div class="meta">${new Date(payload.createdAt).toLocaleString()} ¬∑ ${payload.type}</div>`;
          } catch {}
        });
      }
    </script>
  </body>
  </html>